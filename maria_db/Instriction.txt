
cker-контейнера
06.01.2015

И хотя статья про MySQL, ниже будет много общей информации о “контейнеризации” сетевых сервисов.

В результате мы получим Dockerfile и "docker run" команду для запуска MySQL-сервера в контейнере (нетерпеливые и торопящиеся могут сразу проследовать в секцию Итоги).

Поехали! Предположим, что Docker уже установлен, и у вас открыт терминал под root-ом. Также я буду считать, что вы знаете, что такое Docker и зачем он вам нужен.
Dockerfile

Давайте заведём какую-нибудь папку, например /root/docker-mysql. Зайдем внутрь и положим файл Dockerfile следующего содержания:

FROM ubuntu:14.04
RUN apt-get update && apt-get install -y mysql-server

Это наша отправная точка. На данный момент мы указали, что в качестве базового образа у нас Ubuntu 14.04 LTS и что хотели бы установить MySQL server.

Теперь дайте команду:

docker build .

В первый раз, возможно, придется подождать, если до этого вы ещё не выкачивали образ Ubuntu:

ubuntu:14.04: The image you are pulling has been verified
511136ea3c5a: Pull complete
3b363fd9d7da: Downloading [=>                           ] 5.938 MB/197.2 MB

Когда “билдёжка” завершится, вы должны увидеть сообщение "Successfully built (eprst)". Однако, если обратить внимание на scrollback, то можно заметить шероховатости в виде:

debconf: unable to initialize frontend: Dialog

Установщик жалуется, что его запустили в не-интерактивном режиме. Лучше его успокоить при помощи переменной окружения DEBIAN_FRONTEND:

FROM ubuntu:14.04
RUN apt-get update \
    && DEBIAN_FRONTEND=noninteractive apt-get install -y mysql-server

Теперь единственный warning, который должен возникнуть, выглядит так:

invoke-rc.d: policy-rc.d denied execution of stop.
invoke-rc.d: policy-rc.d denied execution of start.

Это совершенно нормально — базовый образ настроен на предотвращение запуска сервисов, чтобы не “загаживать” результат билда (подробности тут и тут).
Docker image tag

К получившемуся образу (он конечно ещё не доделан) можно обратиться по хеш-тегу, который выводится в сообщении "Successfully built ...", но это неудобно. Лучше присваивать образам метки:

docker build --tag=private/mysql .

Я рекомендую добавлять префикс private, чтобы отличать ваши личные образы от чужих.
Осмотр на месте

Любопытно же посмотреть, что находится внутри только что созданного образа. Самый простой способ — это запустить самоуничтожающийся контейнер в интерактивном режиме:

docker run -i -t --rm private/mysql bash

Попробуйте команду top или which mysqld. Для выхода — exit.
Вынос данных в отдельный volume

Находясь внутри временного контейнера, посмотрите содержимое папки /var/lib/mysql:

cd /var/lib/mysql
ls

Я хочу показать, что файлы данных стали частью образа. Но образ является неизменяемым (read-only), и нет смысла держать их там. Кроме того, данные должны оставаться в целости и сохранности при перестроении образа и перезапуске контейнеров, а сейчас они станут попадать в “эфемерный” copy-on-write слой и жить не дольше контейнера.

Docker предлагает два варианта решения этой ситуации — тома (data volumes) и data volume containers (также можно встретить написание data-only containers).

Обновление (март 2016). В Docker 1.10 были добавлены более удобные именованные тома (named volumes). В этой статье используется устаревшая техника монтирования внешних директорий.

Volume — это, вопреки гордому названию, всего лишь независимая папка, которая монтируется поверх файловой системы образа. Data volume container — это более хитроумный подход, по своему смыслу граничащий с костылём. Официальная документация по обеим темам находится здесь.

Ниже будем использовать тома, а про data volume containers у меня есть отдельная статья.

Внесём следующие изменения в Dockerfile:

FROM ubuntu:14.04
RUN apt-get update \
    && DEBIAN_FRONTEND=noninteractive apt-get install -y mysql-server \
    && rm -rf /var/lib/mysql

Я добавил rm -rf /var/lib/mysql для очистки папки с данными. Но сделал это не отдельной RUN-командой, а с помощью двойного амперсанда.

Зачем? Дело в том, что каждая строка в Dockerfile создает отдельный слой или (по аналогии с Git-ом) отдельный commit. В некоторых случаях это приводит к серьёзным проблемам. Чтобы не занимать дисковое пространство бесполезным хламом, а также чтобы не плодить лишних слоёв, рекомендуют объединять команды в один длинный RUN.

В ту же тему: в сети можно встретить рекомендацию добавлять в Dockerfile "apt-get clean" для удаления скачанных установочных пакетов. При использовании официального Ubuntu-образа в этом нет необходимости, т.к. о зачистке он заботится сам.

Пересоберите образ, выполнив знакомую команду:

docker build --tag=private/mysql .

А чтобы примонтировать том с данными к контейнеру, при запуске используйте флаг -v:

docker run -i -t --rm -v /docker-volumes/mysql-data1:/var/lib/mysql  private/mysql bash

Слева от двоеточия идет “настоящий” путь, справа — точка монтирования внутри контейнера. Папка будет создана автоматически. Вместо /docker-volumes/mysql-data1 вы можете использовать любой путь, какой вам понравится.

Но вот незадача! Папка теперь пустая и с неправильно выставленными правами доступа, и если вы попробуете запустить mysqld, то он справедливо вылетит.

На голову сваливается дополнительная забота…
Инициализация содержимого /var/lib/mysql

При старте контейнера необходимо выполнить код, который проверит состояние /var/lib/mysql и, если там пусто, предпримет необходимые действия.

Рядом с Dockerfile создайте файл start.sh:

#!/bin/bash

if [ ! -d /var/lib/mysql/mysql ]; then
    # Выставляем правильные права доступа
    chown mysql:mysql /var/lib/mysql

    # Инициализируем системные таблицы
    mysql_install_db
fi

В Dockerfile добавьте команду ADD для копирования его в образ. И конечно же, надо не забыть выставить executable-флаг:

FROM ubuntu:14.04

RUN apt-get update \
    && DEBIAN_FRONTEND=noninteractive apt-get install -y mysql-server \
    && rm -rf /var/lib/mysql

ADD start.sh /
RUN chmod +x /start.sh

Повторите docker build и docker run.

Находясь внутри контейнера, выполните:

/start.sh

Выведется много разного текста: Installing MySQL system tables... и так далее. Убедитесь, что последующие запуски /start.sh ничего не делают. А по выходу из контейнера проверьте, что внутри /docker-volumes/mysql-data1 появился характерный контент: performance_schema, ibdata1 и др.

Итак, мы изолировали данные и можем быть спокойны за их сохранность в случае “приключений” с контейнером.

Права на папку /docker-volumes/mysql-data1 при взгляде из основной системы скорее всего будут отличаться от mysql:mysql — это так называемый “permission mess” из-за несоответствия номеров пользователей и групп между контейнером и настоящей системой. Не пугайтесь, ничего страшного в этом нет. Проблемы могут начаться, только если разные контейнеры с разными пользователями используют один и тот же volume, но к счастью, это не наш случай.
Старт MySQL-сервера и подключение к нему

В Dockerfile добавьте:

CMD [ "/start.sh" ]

В start.sh добавьте:

mysqld_safe --bind-address=0.0.0.0

Повторите docker build и запустите контейнер теперь “по-взрослому”:

docker run \
    --name=mysql1 \
    -v /docker-volumes/mysql-data1:/var/lib/mysql \
    -p 172.17.0.1:3306:3306 \
    -d private/mysql

Убедитесь, что контейнер работает в фоне:

docker ps

(в колонке STATUS должно быть "Up сколько-то seconds").

Что мы только что сделали?

В Dockerfile прописали запуск скрипта start.sh в качестве команды по умолчанию. В start.sh добавили запуск MySQL-сервера, принимающего соединения со всех адресов.

Из команды docker run убрали интерактивность (-i -t) и самоуничтожение (--rm), но добавили имя, проброс порта 3306 и работу в фоне (-d).

Публикация порта заслуживает отдельного абзаца. Формат флага таков:

-p IP:HOST_PORT:CONTAINER_PORT

IP-адрес 172.17.0.1 — это адрес виртуального сетевого интерфейса docker0. Уточнить его можно командой:

ip addr show docker0

Таким образом, подключения разрешены из виртуальной сети Docker-а в пределах машины, на которой он “бежит”. Если нужно опубликовать MySQL голым задом наружу, то используйте -p 3306:3306 без указания IP-адреса.

Проверим работоспособность. Сначала подключимся к MySQL через docker exec:

docker exec -i -t mysql1 mysql

Создадим базу и пользователя:

create database db1;
grant all privileges on db1.* to user1@'%' identified by '(надёжный пароль)';
quit

Теперь проверим подключение по сети:

apt-get install mysql-client
mysql -h 172.17.0.1 -u user1 -p

mysql> show databases;
mysql> quit

Всё работает, но есть-таки один нюанс!
Заставляем MySQL реагировать на SIGTERM

Попробуйте остановить контейнер, с помощью такой командной стоки:

docker stop mysql1

Повиснет 10-секундная пауза… Дело в том, что Docker сначала отправляет процессам внутри контейнера сигнал TERM. И если за 10 секунд кто-то не успел закруглиться, то этим тормозам посылается жёсткий KILL.

MySQL не тормоз, просто он не реагирует на SIGTERM. Придётся использовать обходной манёвр.

В start.sh замените:

mysqld_safe --bind-address=0.0.0.0

на:

# Вешаем остановку MySQL на сигнал TERM
trap "mysqladmin shutdown" TERM

# Запускаем MySQL в фоне
mysqld_safe --bind-address=0.0.0.0 &

# Ждём завершения всех порождённых процессов
wait

В последний раз делаем docker build, удаляем старый контейнер (docker rm mysql1) и повторяем предыдущий docker run.
Итоги

Как я и обещал в начале статьи, вот финальный результат:

Dockerfile:

FROM ubuntu:14.04

RUN apt-get update \
    && DEBIAN_FRONTEND=noninteractive apt-get install -y mysql-server \
    && rm -rf /var/lib/mysql

ADD start.sh /
RUN chmod +x /start.sh

CMD [ "/start.sh" ]

start.sh:

#!/bin/bash

if [ ! -d /var/lib/mysql/mysql ]; then
    chown mysql:mysql /var/lib/mysql
    mysql_install_db
fi

trap "mysqladmin shutdown" TERM
mysqld_safe --bind-address=0.0.0.0 &
wait

Сборка образа:

docker build --tag=ИМЯ_ОБРАЗА .

Команда запуска:

docker run \
    --name=ИМЯ_КОНТЕЙНЕРА \
    -v /ПАПКА/С/ДАННЫМИ:/var/lib/mysql \
    -p 172.17.0.1:3306:3306 \
    -d ИМЯ_ОБРАЗА

А прибрать за собой?

В процессе вы много раз запускали билдёжку, и промежуточные результаты захламили диск. Чтобы удалить просроченные образы и ненужные слои, выполните такую команду:

docker rmi $(docker images -q -f dangling=true)

Что насчёт логов?

К счастью, MySQL по умолчанию пишет очень мало логов (фактически логируется только стадия инициализации), так что никаких дополнительных телодвижений не нужно. А вообще ротация логов контейнеров — отдельная интересная тема.
Редактирование my.cnf

Если нужно внести изменения в конфигурационный файл MySQL, то проще всего подкладывать свой конфиг через Dockerfile:

ADD my.cnf /etc/mysql/

Рассуждения о пустом root-пароле

Вы могли заметить, что не был задан пароль для root-пользователя MySQL. Это не страшно до тех пор, пока для root не включен удаленный доступ (плохая идея) и MySQL не опубликован за пределы виртуальной сети Докера. Если вы планируете это менять, то пароль следует назначить:

docker exec mysql1 mysqladmin password 'пароль'

или (для ввода пароля с клавиатуры):

docker exec -i -t mysql1 mysqladmin password

Только в этом случае придётся отредактировать trap-команду в start.sh:

trap "mysqladmin -pПароль shutdown" TERM

Теперь точно всё. В следующих статьях я расскажу про data volume containers и ротацию логов контейнеров.

P.S. На картинке с китами и дельфинами обыгрываются логотипы Docker и MySQL.
◂ Using dnsmasq to link Docker containers
Docker: data volume containers ▸

Gravatar

    Темы
    Docker
    Контакты
    blog@amartynov.ru
    VK
    Strava
    Mixcloud
    Поиск


